Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 1
labs2b.asm



      1				     ;**************************************************************************
      2				     ; LAB SESSION 2 - EXERCISE	3 MBS 2018
      3				     ; TEAM #6
      4				     ; AUTHORS:
      5				     ; Lucia Asencio - lucia.asencio@estudiante.uam.es
      6				     ; David García Fernández -	david.garcia03@estudiante.uam.es
      7				     ;**************************************************************************
      8
      9				     ;**************************************************************************
     10				     ; DATA SEGMENT DEFINITION
     11	0000			     DATOS SEGMENT
     12
     13	0000  50 6C 65 61 73 65	2C+  request db	'Please, introduce a number between 0 and 15: ', '$'
     14	      20 69 6E 74 72 6F	64+
     15	      75 63 65 20 61 20	6E+
     16	      75 6D 62 65 72 20	62+
     17	      65 74 77 65 65 6E	20+
     18	      30 20 61 6E 64 20	31+
     19	      35 3A 20 24
     20
     21				     ;;	The reading buffer needs the first byte	to save	the
     22				     ;;	max. number of bytes to	read, another to save
     23				     ;;	the number of bytes read and another 3 bytes
     24				     ;;	to save	both digits of the number and the carriage
     25				     ;;	return.
     26
     27	002E  03 ?? 03*(??) 24	     read db 3,	?, 3 dup (?), '$'
     28	0034  4E 75 6D 62 65 72	20+  errtxt db 'Number should be less than 15 and greater than 0.', 13,	10,'$'
     29	      73 68 6F 75 6C 64	20+
     30	      62 65 20 6C 65 73	73+
     31	      20 74 68 61 6E 20	31+
     32	      35 20 61 6E 64 20	67+
     33	      72 65 61 74 65 72	20+
     34	      74 68 61 6E 20 30	2E+
     35	      0D 0A 24
     36	0068  04*(00)		     bin db 4 dup (0)
     37	006C			     DATOS ENDS
     38
     39				     ;**************************************************************************
     40				     ; STACK SEGMENT DEFINITION
     41	0000			     PILA SEGMENT STACK	"STACK"
     42	0000			     PILA ENDS
     43
     44				     ;**************************************************************************
     45				     ; EXTRA SEGMENT DEFINITION
     46	0000			     EXTRA SEGMENT
     47	0000			     EXTRA ENDS
     48
     49				     ;**************************************************************************
     50				     ; CODE SEGMENT DEFINITION
     51	0000			     CODE SEGMENT
     52				     ASSUME CS:	CODE, DS: DATOS, ES: EXTRA, SS:	PILA
     53				     ; BEGINNING OF THE	MAIN PROCEDURE
     54	0000			     INICIO PROC
     55				     ; INITIALIZE THE SEGMENT REGISTERS
     56	0000  B8 0000s			     MOV AX, DATOS
     57	0003  8E D8			     MOV DS, AX
Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 2
labs2b.asm



     58
     59					     ; Requesting a number
     60
     61	0005  B4 09			     MOV AH, 9h				; First	we select the interruption type.
     62	0007  BA 0000r			     MOV DX, OFFSET request ; Now we move to dx	the offset of the string.
     63	000A  CD 21			     INT 21H		    ; Calling the interruption.
     64
     65					     ; Reading number
     66
     67	000C  B4 0A			     MOV AH, 0Ah	    ; Selecting	the interruption.
     68	000E  BA 002Er			     MOV DX, OFFSET read    ; DX needs the offset of the string.
     69	0011  CD 21			     INT 21H		    ; Reading from keyboard.
     70
     71	0013  E8 0010			     CALL DECIMAL	    ; Converting to decimal.
     72	0016  E8 0029			     CALL CHECK		    ; Checking if the number is	valid.
     73
     74					     ; Now that	the number is valid we can
     75					     ; convert it to binary.
     76
     77	0019  BB 0000			     MOV BX, 0			; Cleaning BX.
     78	001C  8A D8			     MOV BL, AL		    ; The procedure needs the number in	BL
     79	001E  E8 0036			     CALL BINARY	    ; Calling the function.
     80
     81
     82					     ; PROGRAM END
     83	0021  B8 4C00			     MOV AX, 4C00H
     84	0024  CD 21			     INT 21H
     85	0026			     INICIO ENDP
     86
     87
     88				     ;__________________________________________________________________________
     89				     ; SUBRUTINE TO TRANSLATE A	SEQUENCE OF ASCII VALUES TO INTEGER
     90				     ; INPUT:  A string	in the memory position with tag	'read'
     91				     ; OUTPUT: AL = Decimal value of the string
     92				     ;__________________________________________________________________________
     93
     94	0026			     DECIMAL PROC NEAR
     95
     96	0026  A0 0030r			     MOV AL, read[2] ; Saving in AL the	firt character read.
     97	0029  04 D0			     ADD AL, -48     ; Converting it to	a non-ascii value.
     98
     99					     ; Checking	if the number of characters is 1 or 2
    100
    101	002B  8A 1E 002Fr		     MOV BL, read[1] ; Number of characters read.
    102	002F  80 FB 02			     CMP BL, 2	     ; If there	is only	one character read...
    103	0032  75 0D			     JNE ONE	     ; ...we have finished.
    104
    105					     ; Converting character 1
    106
    107	0034  B1 0A			     MOV CL, 10	     ; The first character is the tens.
    108	0036  F6 E1			     MUL CL	     ; Multiplying the character.
    109
    110					     ; Converting character 2
    111
    112	0038  8A 0E 0031r		     MOV CL, read[3] ; Saving the second character.
    113	003C  80 C1 D0			     ADD CL, -48     ; Converting it to	non-ascii.
    114	003F  02 C1			     ADD AL, CL	     ; Adding the complete number
Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 3
labs2b.asm



    115
    116	0041			     ONE:
    117	0041  C3			     RET
    118
    119	0042			     DECIMAL ENDP
    120
    121				     ;__________________________________________________________________________
    122				     ; SUBRUTINE TO CHECK IF A NUMBER BELONG TO	RANGE [0,15]
    123				     ; INPUT:  AL = Number to check.
    124				     ; OUTPUT: If number does not belong to the	range we print an error	message
    125				     ;		       and stop	the execution.
    126				     ;__________________________________________________________________________
    127
    128	0042			     CHECK PROC	NEAR
    129	0042  3C 0F			     CMP AL, 15	; 15 should be greater or equal	to 15.
    130	0044  7F 05			     JG	ERROR	; In other case	we raise the error.
    131
    132	0046  3C 00			     CMP AL, 0	; AL should be greater or equal	to 0.
    133	0048  7C 01			     JL	ERROR	; In other case	we raise the error.
    134	004A  C3			     RET
    135
    136	004B			     ERROR:
    137					     ; Printing	error.
    138	004B  B4 09			     MOV AH, 9h		   ; First we select the interruption type.
    139	004D  BA 0034r			     MOV DX, OFFSET errtxt ; Now we move to dx the offset of the string.
    140	0050  CD 21			     INT 21H		   ; Calling the interruption.
    141
    142					     ; PROGRAM END
    143	0052  B8 4C00			     MOV AX, 4C00H
    144	0055  CD 21			     INT 21H
    145
    146	0057			     CHECK ENDP
    147
    148				     ;__________________________________________________________________________
    149				     ; SUBRUTINE TO TRANSLATE AN INTEGER TO BINARY
    150				     ; INPUT:  BX = Number to be translated to binary.
    151				     ; OUTPUT: DX = Segment where the string is	saved, AX = Offset of the string.
    152				     ;__________________________________________________________________________
    153
    154	0057			     BINARY PROC NEAR
    155	0057  8B C3			     MOV AX, BX	; Moving the number to AX to divide it.
    156	0059  B1 02			     MOV CL, 2	; To get the binary characters
    157							; we need to divide by two.
    158	005B  BB 0004			     MOV BX, 4	; The number's max. size will be
    159							; four digits so we write backguards
    160								; from the fourth position.
    161
    162	005E			     DIVIDE:
    163	005E  F6 F1			     DIV CL		; Division.
    164	0060  83 C3 FF			     ADD BX, -1		; Decreasing the pointer of the	string
    165								; to write the next character.
    166
    167	0063  88 A7 0068r		     MOV bin[BX], AH	; Writing the remainder	in memory.
    168	0067  B4 00			     MOV AH, 0		; Cleaning remainder.
    169
    170	0069  3C 00			     CMP AL, 0		; If the quotient is not zero we
    171	006B  75 F1			     JNE DIVIDE		; continue with	the algorithm.
Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 4
labs2b.asm



    172
    173					     ; If the quotient is zero the algorithm stops.
    174
    175	006D  8C DA			     MOV DX, DS		; DX contains the string's segment.
    176	006F  B8 0068r			     MOV AX, OFFSET bin	; AX contains the OFFSET.
    177	0072  C3			     RET
    178	0073			     BINARY ENDP
    179
    180				     ; END OF CODE SEGMENT
    181	0073			     CODE ENDS
    182				     ; END OF PROGRAM. OBS: INCLUDES THE ENTRY OR THE FIRST PROCEDURE (i.e. “INICIO”)
    183				     END INICIO
Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 5
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "04/02/18"
??FILENAME			  Text	 "labs2b  "
??TIME				  Text	 "01:18:23"
??VERSION			  Number 0200
@CPU				  Text	 0101H
@CURSEG				  Text	 CODE
@FILENAME			  Text	 LABS2B
@WORDSIZE			  Text	 2
BIN				  Byte	 DATOS:0068
BINARY				  Near	 CODE:0057
CHECK				  Near	 CODE:0042
DECIMAL				  Near	 CODE:0026
DIVIDE				  Near	 CODE:005E
ERROR				  Near	 CODE:004B
ERRTXT				  Byte	 DATOS:0034
INICIO				  Near	 CODE:0000
ONE				  Near	 CODE:0041
READ				  Byte	 DATOS:002E
REQUEST				  Byte	 DATOS:0000

Groups & Segments		  Bit Size Align  Combine Class

CODE				  16  0073 Para	  none
DATOS				  16  006C Para	  none
EXTRA				  16  0000 Para	  none
PILA				  16  0000 Para	  Stack	  STACK
