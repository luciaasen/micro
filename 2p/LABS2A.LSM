Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 1
labs2a.asm



      1
      2				     ;**************************************************************************
      3				     ; LAB SESSION 2 - EXERCISE	2 MBS 2018
      4				     ; TEAM #6
      5				     ; AUTHORS:
      6				     ; Lucia Asencio - lucia.asencio@estudiante.uam.es
      7				     ; David García Fernández	- david.garcia03@estudiante.uam.es
      8				     ;**************************************************************************
      9
     10				     ;**************************************************************************
     11				     ; DATA SEGMENT DEFINITION
     12	0000			     DATOS SEGMENT
     13
     14	0000  07*(00)		     result db 7 dup (0) ; Multiplying vector(1,4) x matrix(4,7) results in a
     15							 ; vector(1,7) for which we allocate memory
     16
     17	0007  01 00 00 00	     matrix db 1, 0, 0,	0; ;We allocate	the 7x4	Transposed Generation Matrix
     18	000B  00 01 00 00		    db 0, 1, 0,	0  ;to make a better memory access when	multiplying
     19	000F  00 00 01 00		    db 0, 0, 1,	0
     20	0013  00 00 00 01		    db 0, 0, 0,	1
     21	0017  01 01 00 01		    db 1, 1, 0,	1
     22	001B  01 00 01 01		    db 1, 0, 1,	1
     23	001F  00 01 01 01		    db 0, 1, 1,	1
     24
     25	0023  49 6E 70 75 74 3A	20+  input db 'Input: "X X X X"', 13, 10, '$'
     26	      22 58 20 58 20 58	20+
     27	      58 22 0D 0A 24
     28	0036  4F 75 74 70 75 74	3A+  output db 'Output:	"X X X X X X X"', 13, 10, '$'
     29	      20 22 58 20 58 20	58+
     30	      20 58 20 58 20 58	20+
     31	      58 22 0D 0A 24
     32	0050  43 6F 6D 70 75 74	61+  comp db 'Computation:', 13, 10, '$'
     33	      74 69 6F 6E 3A 0D	0A+
     34	      24
     35	005F  22 0D 0A 24	     fin db '"', 13, 10, '$'
     36	0063  20 20 20 20 20 20	7C+  ini db  '	    | P1 | P2 |	D1 | P4	| D2 | D3 | D4', 13, 10, '$'
     37	      20 50 31 20 7C 20	50+
     38	      32 20 7C 20 44 31	20+
     39	      7C 20 50 34 20 7C	20+
     40	      44 32 20 7C 20 44	33+
     41	      20 7C 20 44 34 0D	0A+
     42	      24
     43	008E  57 6F 72 64 20 20	7C+  word_ db 'Word  | ?  | ?  | X  | ?	 | X  |	X  | X', 13, 10, '$'
     44	      20 3F 20 20 7C 20	3F+
     45	      20 20 7C 20 58 20	20+
     46	      7C 20 3F 20 20 7C	20+
     47	      58 20 20 7C 20 58	20+
     48	      20 7C 20 58 0D 0A	24
     49	00B8  50 31 20 20 20 20	7C+  p1	db   'P1    | X	 |    |	X  |	| X  |	  | X',	13, 10,	'$'
     50	      20 58 20 20 7C 20	20+
     51	      20 20 7C 20 58 20	20+
     52	      7C 20 20 20 20 7C	20+
     53	      58 20 20 7C 20 20	20+
     54	      20 7C 20 58 0D 0A	24
     55	00E2  50 32 20 20 20 20	7C+  p2	db   'P2    |	 | X  |	X  |	|    | X  | X',	13, 10,	'$'
     56	      20 20 20 20 7C 20	58+
     57	      20 20 7C 20 58 20	20+
Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 2
labs2a.asm



     58	      7C 20 20 20 20 7C	20+
     59	      20 20 20 7C 20 58	20+
     60	      20 7C 20 58 0D 0A	24
     61	010C  50 34 20 20 20 20	7C+  p4	db   'P4    |	 |    |	   | X	| X  | X  | X',	13, 10,	'$'
     62	      20 20 20 20 7C 20	20+
     63	      20 20 7C 20 20 20	20+
     64	      7C 20 58 20 20 7C	20+
     65	      58 20 20 7C 20 58	20+
     66	      20 7C 20 58 0D 0A	24
     67
     68	0136			     DATOS ENDS
     69
     70				     ;**************************************************************************
     71				     ; STACK SEGMENT DEFINITION
     72	0000			     PILA SEGMENT STACK	"STACK"
     73	0000			     PILA ENDS
     74
     75				     ;**************************************************************************
     76				     ; EXTRA SEGMENT DEFINITION
     77	0000			     EXTRA SEGMENT
     78	0000			     EXTRA ENDS
     79
     80				     ;**************************************************************************
     81				     ; CODE SEGMENT DEFINITION
     82	0000			     CODE SEGMENT
     83				     ASSUME CS:	CODE, DS: DATOS, ES: EXTRA, SS:	PILA
     84				     ; BEGINNING OF THE	MAIN PROCEDURE
     85	0000			     INICIO PROC
     86					 ; INITIALIZE THE SEGMENT REGISTERS
     87	0000  B8 0000s			 MOV AX, DATOS
     88	0003  8E D8			 MOV DS, AX
     89
     90					 ; DX:BX contains the vector to	be multiplied
     91	0005  BA 0100			 MOV DX, 0100h
     92	0008  BB 0101			 MOV BX, 0101h
     93
     94					 ; Calling the function	that multiplies	vector x matrix
     95	000B  E8 0005			 CALL MULTIPLY
     96
     97					     ; PROGRAM END
     98	000E  B8 4C00			     MOV AX, 4C00H
     99	0011  CD 21			     INT 21H
    100
    101	0013			     INICIO ENDP
    102
    103
    104				     ;__________________________________________________________________________
    105				     ; SUBROUTINE THAT COMPUTES	THE MULTIPLICATION OF A	VECTOR AND A MATRIX AND
    106				     ; RETURNS THE RESULT VECTOR MODULO	2
    107				     ; INPUT:	 4 BINARY DIGITS WILL BE READ FROM DX:BX
    108				     ; OUTPUT:	 THE VECTOR WILL BE STORED IN [DX:AX]
    109				     ;__________________________________________________________________________
    110
    111	0013			     MULTIPLY PROC NEAR
    112					 ; We could not	do just	a loop to multiply the whole vector,
    113					 ; as it was contained in two different	registers
    114					 ; Therefore, we needed	2 loops, and each of them having 2 iterations
Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 3
labs2a.asm



    115					 ; We thought expanding	the loop was a better solution as, in the end,
    116					 ; it was easier to understand than the	2 double loops
    117
    118	0013  BE 0000			 MOV SI, 0 ; DI	will be	the result vector index	and matrix row index
    119	0016			     EACH_ROW:
    120					 ; We will write in result[SI],	but we need to read matrix[BP +	SI*4]
    121					 ; Therefore, we will compute DI <= SI*4
    122					 ; Instead of using MUL, we will use SHL
    123	0016  8B FE			 MOV DI, SI			 ; We write a copy of SI in DI
    124	0018  B1 02			 MOV CL, 2			 ; We want to shift twice
    125	001A  D3 E7			 SHL DI, CL			 ; DI <= 4*DI
    126
    127	001C  8A C6			 MOV AL, BYTE PTR DH		 ; Factor1 = input vector 1st element
    128	001E  F6 A5 0007r		 MUL matrix[0][DI]		 ; Factor2 = Matrix element multiplied
    129	0022  00 84 0000r		 ADD result[SI], BYTE PTR AL	 ; Result in AX	is added to what we had
    130									 ; in AL
    131	0026  46			 INC SI				 ; Increment the matrix	rows index
    132	0027  83 FE 07			 CMP SI, 7			 ; Until we have multiplied the	7 rows
    133	002A  75 EA			 JNZ EACH_ROW
    134
    135					 ; Now,	we have	to repeat the same but with the	part of	the input vector
    136					 ; that	is in DL
    137
    138	002C  BE 0000			 MOV SI, 0 ; DI	will be	the result vector index	and matrix row index
    139	002F			     EACH_ROW2:
    140					 ; Same	as before, we will compute DI <= SI*4
    141	002F  8B FE			 MOV DI, SI			 ; We write a copy of SI in DI
    142	0031  B1 02			 MOV CL, 2			 ; We want to shift twice
    143	0033  D3 E7			 SHL DI, CL			 ; DI <= 4*DI
    144
    145	0035  8A C2			 MOV AL, BYTE PTR DL		 ; Factor1 = input vector 2nd element
    146	0037  F6 A5 0008r		 MUL matrix[1][DI]		 ; Factor2 = Matrix element multiplied
    147	003B  00 84 0000r		 ADD result[SI], BYTE PTR AL	 ; Result in AX	is added to what we had
    148									 ; in AL
    149	003F  46			 INC SI				 ; Increment the matrix	rows index
    150	0040  83 FE 07			 CMP SI, 7			 ; Until we have multiplied the	7 rows
    151	0043  75 EA			 JNZ EACH_ROW2
    152
    153					 ; Now,	we have	to repeat the same but with the	part of	the input vector
    154					 ; that	is in BH
    155
    156	0045  BE 0000			 MOV SI, 0 ; DI	will be	the result vector index	and matrix row index
    157	0048			     EACH_ROW3:
    158					 ; Same	as before, we will compute DI <= SI*4
    159	0048  8B FE			 MOV DI, SI			 ; We write a copy of SI in DI
    160	004A  B1 02			 MOV CL, 2			 ; We want to shift twice
    161	004C  D3 E7			 SHL DI, CL			 ; DI <= 4*DI
    162
    163	004E  8A C7			 MOV AL, BYTE PTR BH		 ; Factor1 = input vector 3rd element
    164	0050  F6 A5 0009r		 MUL matrix[2][DI]		 ; Factor2 = Matrix element multiplied
    165	0054  00 84 0000r		 ADD result[SI], BYTE PTR AL	 ; Result in AX	is added to what we had
    166									 ; in AL
    167	0058  46			 INC SI				 ; Increment the matrix	rows index
    168	0059  83 FE 07			 CMP SI, 7			 ; Until we have multiplied the	7 rows
    169	005C  75 EA			 JNZ EACH_ROW3
    170
    171
Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 4
labs2a.asm



    172					 ; Now,	we have	to repeat the same but with the	part of	the input vector
    173					 ; that	is in BL
    174
    175	005E  BE 0000			 MOV SI, 0 ; DI	will be	the result vector index	and matrix row index
    176	0061			     EACH_ROW4:
    177					 ; Same	as before, we will compute DI <= SI*4
    178	0061  8B FE			 MOV DI, SI			 ; We write a copy of SI in DI
    179	0063  B1 02			 MOV CL, 2			 ; We want to shift twice
    180	0065  D3 E7			 SHL DI, CL			 ; DI <= 4*DI
    181
    182	0067  8A C3			 MOV AL, BYTE PTR BL		 ; Factor1 = input vector 4th element
    183	0069  F6 A5 000Ar		 MUL matrix[3][DI]		 ; Factor2 = Matrix element multiplied
    184	006D  00 84 0000r		 ADD result[SI], BYTE PTR AL	 ; Result in AX	is added to what we had
    185									 ; in AL
    186	0071  46			 INC SI				 ; Increment the matrix	rows index
    187	0072  83 FE 07			 CMP SI, 7			 ; Until we have multiplied the	7 rows
    188	0075  75 EA			 JNZ EACH_ROW4
    189
    190					 ; The multiplication is done, now we compute modulo
    191					 ; We use unsigned division (we	are working with numbers that are
    192					 ; the result of adding	1's and	0's)
    193					 ; We use 8-bit	division because the greatest number we	are going to
    194					 ; divide is 1*1 + 1*1 + 1*1 + 1*1 = 4
    195	0077  B1 02			 MOV CL, 2 ; CL	<= 2 because we	are working modulo 2, 2	is the divisor
    196	0079  BF 0000			 MOV DI, 0 ; DI	will index the result vector
    197
    198
    199	007C			     MODULO:
    200	007C  B4 00			 MOV AH, 00h			; AX is	the dividend: AH:AL = 00h:result[DI]
    201	007E  8A 85 0000r		 MOV AL, result[DI]
    202	0082  F6 F1			 DIV CL				; AX/2
    203	0084  88 A5 0000r		 MOV result [DI], AH		; result[DI] <=	remainder
    204
    205	0088  47			 INC DI				; We repeat for	each element
    206	0089  83 FF 07			 CMP DI, 7			; of the result	vector
    207	008C  75 EE			 JNZ MODULO
    208
    209					 ; Store result	vector position	in DX:AX
    210	008E  8C DA			 MOV DX, DS		 ; DX is the segment where the result vector is.
    211	0090  B8 0000r			 MOV AX, OFFSET	result	 ; AX contains the OFFSET of the result	vector.
    212
    213
    214					 ; Last	part: printing
    215	0093  8B CA			 MOV CX, DX		 ; We need to preserve the value of DX
    216								 ; since it contains part of the input
    217
    218					 ; ---------- INPUT LINE -----------
    219					 ; We fill the 'X' in the input	string with the	input vector
    220					 ;To get the ASCII code	of register, we	add it up with "0"
    221	0095  A0 0000r			 MOV AL, result[0]
    222	0098  04 30			 ADD AL, "0"
    223	009A  A2 002Br			 MOV input[8], AL
    224	009D  A0 0001r			 MOV AL, result[1]
    225	00A0  04 30			 ADD AL, "0"
    226	00A2  A2 002Dr			 MOV input[10],	AL
    227	00A5  A0 0002r			 MOV AL, result[2]
    228	00A8  04 30			 ADD AL, "0"
Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 5
labs2a.asm



    229	00AA  A2 002Fr			 MOV input[12],	AL
    230	00AD  A0 0003r			 MOV AL, result[3]
    231	00B0  04 30			 ADD AL, "0"
    232	00B2  A2 0031r			 MOV input[14],	AL
    233
    234					 ;We print the input string
    235	00B5  BA 0023r			 MOV DX, OFFSET	input	 ; DX has the offset of	the string
    236	00B8  B4 09			 MOV AH, 9		 ; Function 9: print ascii string
    237	00BA  CD 21			 INT 21H
    238
    239					 ; ---------- OUTPUT LINE ----------
    240					 ;We fill the 'X' of the output	string with the	reordered output vector
    241					 ;To get the ASCII code	of register, we	add it up with "0"
    242	00BC  A0 0004r			 MOV AL, result[4]
    243	00BF  04 30			 ADD AL, "0"
    244	00C1  A2 003Fr			 MOV output[9],	AL    ;P1
    245	00C4  A0 0005r			 MOV AL, result[5]
    246	00C7  04 30			 ADD AL, "0"
    247	00C9  A2 0041r			 MOV output[11], AL   ;P2
    248	00CC  A0 0000r			 MOV AL, result[0]
    249	00CF  04 30			 ADD AL, "0"
    250	00D1  A2 0043r			 MOV output[13], AL   ;D1
    251	00D4  A0 0006r			 MOV AL, result[6]
    252	00D7  04 30			 ADD AL, "0"
    253	00D9  A2 0045r			 MOV output[15], AL   ;P4
    254	00DC  A0 0001r			 MOV AL, result[1]
    255	00DF  04 30			 ADD AL, "0"
    256	00E1  A2 0047r			 MOV output[17], AL   ;D2
    257	00E4  A0 0002r			 MOV AL, result[2]
    258	00E7  04 30			 ADD AL, "0"
    259	00E9  A2 0049r			 MOV output[19], AL   ;D3
    260	00EC  A0 0003r			 MOV AL, result[3]
    261	00EF  04 30			 ADD AL, "0"
    262	00F1  A2 004Br			 MOV output[21], AL   ;D4
    263
    264					 ;We print the output string
    265	00F4  BA 0036r			 MOV DX, OFFSET	output	  ; DX has the offset of the string
    266	00F7  B4 09			 MOV AH, 9		 ; Function 9: print ascii string
    267	00F9  CD 21			 INT 21H
    268
    269					 ; -------- COMPUTATION	MATRIX -------
    270					 ;We print the computation line
    271					 ;To get the ASCII code	of register, we	add it up with "0"
    272	00FB  BA 0050r			 MOV DX, OFFSET	comp	 ; DX has the offset of	the string
    273	00FE  B4 09			 MOV AH, 9		 ; Function 9: print ascii string
    274	0100  CD 21			 INT 21H
    275
    276					 ;We print the first line
    277	0102  BA 0063r			 MOV DX, OFFSET	ini	 ; DX has the offset of	the string
    278	0105  B4 09			 MOV AH, 9		 ; Function 9: print ascii string
    279	0107  CD 21			 INT 21H
    280
    281					 ;We fill the 'X' in 'Word...' line with D1, D2, D3, D4
    282					 ;To get the ASCII code	of register, we	add it up with "0"
    283	0109  A0 0000r			 MOV AL, result[0]
    284	010C  04 30			 ADD AL, "0"
    285	010E  A2 00A0r			 MOV word_[18],	AL
Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 6
labs2a.asm



    286	0111  A0 0001r			 MOV AL, result[1]
    287	0114  04 30			 ADD AL, "0"
    288	0116  A2 00AAr			 MOV word_[28],	AL
    289	0119  A0 0002r			 MOV AL, result[2]
    290	011C  04 30			 ADD AL, "0"
    291	011E  A2 00AFr			 MOV word_[33],	AL
    292	0121  A0 0003r			 MOV AL, result[3]
    293	0124  04 30			 ADD AL, "0"
    294	0126  A2 00B4r			 MOV word_[38],	AL
    295
    296					 ; We print the	'Word...' line
    297	0129  BA 008Er			 MOV DX, OFFSET	word_	  ; DX has the offset of the string
    298	012C  B4 09			 MOV AH, 9		 ; Function 9: print ascii string
    299	012E  CD 21			 INT 21H
    300
    301					 ;We fill the 'X' in the 'P1...' line with P1, D1, D2, D4
    302					 ;To get the ASCII code	of register, we	add it up with "0"
    303	0130  A0 0004r			 MOV AL, result[4]
    304	0133  04 30			 ADD AL, "0"
    305	0135  A2 00C0r			 MOV p1[8], AL
    306	0138  A0 0000r			 MOV AL, result[0]
    307	013B  04 30			 ADD AL, "0"
    308	013D  A2 00CAr			 MOV p1[18], AL
    309	0140  A0 0001r			 MOV AL, result[1]
    310	0143  04 30			 ADD AL, "0"
    311	0145  A2 00D4r			 MOV p1[28], AL
    312	0148  A0 0003r			 MOV AL, result[3]
    313	014B  04 30			 ADD AL, "0"
    314	014D  A2 00DEr			 MOV p1[38], AL
    315
    316					 ; We print the	'P1...'	line
    317	0150  BA 00B8r			 MOV DX, OFFSET	p1	 ; DX has the offset of	the string
    318	0153  B4 09			 MOV AH, 9		 ; Function 9: print ascii string
    319	0155  CD 21			 INT 21H
    320
    321					 ;We fill the 'X' in the 'P2...' line with P2, D1, D3, D4
    322					 ;To get the ASCII code	of register, we	add it up with "0"
    323	0157  A0 0005r			 MOV AL, result[5]
    324	015A  04 30			 ADD AL, "0"
    325	015C  A2 00EFr			 MOV p2[13], AL
    326	015F  A0 0000r			 MOV AL, result[0]
    327	0162  04 30			 ADD AL, "0"
    328	0164  A2 00F4r			 MOV p2[18], AL
    329	0167  A0 0002r			 MOV AL, result[2]
    330	016A  04 30			 ADD AL, "0"
    331	016C  A2 0103r			 MOV p2[33], AL
    332	016F  A0 0003r			 MOV AL, result[3]
    333	0172  04 30			 ADD AL, "0"
    334	0174  A2 0108r			 MOV p2[38], AL
    335
    336					 ; We print the	'P2...'	line
    337	0177  BA 00E2r			 MOV DX, OFFSET	p2	 ; DX has the offset of	the string
    338	017A  B4 09			 MOV AH, 9		 ; Function 9: print ascii string
    339	017C  CD 21			 INT 21H
    340
    341					 ;We fill the 'X' in the 'P3...' line with P4, D2, D3, D4
    342					 ;To get the ASCII code	of register, we	add it up with "0"
Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 7
labs2a.asm



    343	017E  A0 0006r			 MOV AL, result[6]
    344	0181  04 30			 ADD AL, "0"
    345	0183  A2 0123r			 MOV p4[23], AL
    346	0186  A0 0001r			 MOV AL, result[1]
    347	0189  04 30			 ADD AL, "0"
    348	018B  A2 0128r			 MOV p4[28], AL
    349	018E  A0 0002r			 MOV AL, result[2]
    350	0191  04 30			 ADD AL, "0"
    351	0193  A2 012Dr			 MOV p4[33], AL
    352	0196  A0 0003r			 MOV AL, result[3]
    353	0199  04 30			 ADD AL, "0"
    354	019B  A2 0132r			 MOV p4[38], AL
    355
    356					 ; We print the	'P4...'	line
    357	019E  BA 010Cr			 MOV DX, OFFSET	p4	 ; DX has the offset of	the string
    358	01A1  B4 09			 MOV AH, 9		 ; Function 9: print ascii string
    359	01A3  CD 21			 INT 21H
    360
    361	01A5  C3			 RET
    362	01A6			     MULTIPLY ENDP
    363
    364				     ; END OF CODE SEGMENT
    365	01A6			     CODE ENDS
    366				     ; END OF PROGRAM. OBS: INCLUDES THE ENTRY OR THE FIRST PROCEDURE
    367				     END INICIO
Turbo Assembler	 Version 2.0	    04/02/18 01:18:23	    Page 8
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "04/02/18"
??FILENAME			  Text	 "labs2a  "
??TIME				  Text	 "01:18:22"
??VERSION			  Number 0200
@CPU				  Text	 0101H
@CURSEG				  Text	 CODE
@FILENAME			  Text	 LABS2A
@WORDSIZE			  Text	 2
COMP				  Byte	 DATOS:0050
EACH_ROW			  Near	 CODE:0016
EACH_ROW2			  Near	 CODE:002F
EACH_ROW3			  Near	 CODE:0048
EACH_ROW4			  Near	 CODE:0061
FIN				  Byte	 DATOS:005F
INI				  Byte	 DATOS:0063
INICIO				  Near	 CODE:0000
INPUT				  Byte	 DATOS:0023
MATRIX				  Byte	 DATOS:0007
MODULO				  Near	 CODE:007C
MULTIPLY			  Near	 CODE:0013
OUTPUT				  Byte	 DATOS:0036
P1				  Byte	 DATOS:00B8
P2				  Byte	 DATOS:00E2
P4				  Byte	 DATOS:010C
RESULT				  Byte	 DATOS:0000
WORD_				  Byte	 DATOS:008E

Groups & Segments		  Bit Size Align  Combine Class

CODE				  16  01A6 Para	  none
DATOS				  16  0136 Para	  none
EXTRA				  16  0000 Para	  none
PILA				  16  0000 Para	  Stack	  STACK
